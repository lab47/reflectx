// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package reflectx

import (
	"fmt"
	"hash/maphash"
	"math/rand"
	"reflect"
	"unsafe"
)

const (
	ptrSize = 8
	c0      = uint64((8-ptrSize)/4*2860486313 + (ptrSize-4)/4*33054211828000289)
	c1      = uint64((8-ptrSize)/4*3267000013 + (ptrSize-4)/4*23344194077549503)
)

func memhash8(p unsafe.Pointer, h uint64, s maphash.Seed) uint64 {
	b := *(*[1]byte)(p)
	return maphash.Bytes(s, b[:]) ^ h
}

func memhash16(p unsafe.Pointer, h uint64, s maphash.Seed) uint64 {
	b := *(*[2]byte)(p)
	return maphash.Bytes(s, b[:]) ^ h
}

func memhash32(p unsafe.Pointer, h uint64, s maphash.Seed) uint64 {
	b := *(*[4]byte)(p)
	return maphash.Bytes(s, b[:]) ^ h
}

func memhash64(p unsafe.Pointer, h uint64, s maphash.Seed) uint64 {
	b := *(*[8]byte)(p)
	return maphash.Bytes(s, b[:]) ^ h
}

func strhash(rv reflect.Value, h uint64, s maphash.Seed) uint64 {
	return maphash.String(s, rv.String()) ^ h
}

// NOTE: Because NaN != NaN, a map can contain any
// number of (mostly useless) entries keyed with NaNs.
// To avoid long hash chains, we assign a random number
// as the hash value for a NaN.

func f32hash(rv reflect.Value, h uint64, s maphash.Seed) uint64 {
	f := float32(rv.Float())
	switch {
	case f == 0:
		return c1 * (c0 ^ h) // +0, -0
	case f != f:
		return c1 * (c0 ^ h ^ uint64(rand.Int())) // any kind of NaN
	default:
		return memhash32(unsafe.Pointer(&f), h, s)
	}
}

func f64hash(rv reflect.Value, h uint64, s maphash.Seed) uint64 {
	f := rv.Float()
	switch {
	case f == 0:
		return c1 * (c0 ^ h) // +0, -0
	case f != f:
		return c1 * (c0 ^ h ^ uint64(rand.Int())) // any kind of NaN
	default:
		return memhash64(unsafe.Pointer(&f), h, s)
	}
}

func c64hash(rv reflect.Value, h uint64, s maphash.Seed) uint64 {
	comp := complex64(rv.Complex())

	x := (*[2]float32)(unsafe.Pointer(&comp))
	return f32hash(reflect.ValueOf(x[1]), f32hash(reflect.ValueOf(x[0]), h, s), s)
}

func c128hash(rv reflect.Value, h uint64, s maphash.Seed) uint64 {
	comp := rv.Complex()

	x := (*[2]float64)(unsafe.Pointer(&comp))
	return f64hash(reflect.ValueOf(x[1]), f64hash(reflect.ValueOf(x[0]), h, s), s)
}

// typehash computes the hash of the object of type t at address p.
// h is the seed.
// This function is seldom used. Most maps use for hashing either
// fixed functions (e.g. f32hash) or compiler-generated functions
// (e.g. for a type like struct { x, y string }). This implementation
// is slower but more general and is used for hashing interface types
// (called from interhash or nilinterhash, above) or for hashing in
// maps generated by reflect.MapOf (reflect_typehash, below).
// Note: this function must match the compiler generated
// functions exactly. See issue 37716.
func typehash(rv reflect.Value, h uint64, s maphash.Seed) uint64 {
	t := rv.Type()

	if rv.Kind() == reflect.Pointer {
		x := rv.UnsafePointer()
		p := unsafe.Pointer(&x)

		// Handle ptr sizes specially, see issue 37086.
		switch t.Size() {
		case 1:
			return memhash8(p, h, s)
		case 2:
			return memhash16(p, h, s)
		case 4:
			return memhash32(p, h, s)
		case 8:
			return memhash64(p, h, s)
		default:
			panic("unsupported size")
		}
	}
	switch t.Kind() {
	case reflect.Bool:
		if rv.Bool() {
			return maphash.Bytes(s, []byte{1}) ^ h
		}
		return maphash.Bytes(s, []byte{0}) ^ h
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		x := rv.Int()
		p := unsafe.Pointer(&x)

		switch t.Size() {
		case 1:
			return memhash8(p, h, s)
		case 2:
			return memhash16(p, h, s)
		case 4:
			return memhash32(p, h, s)
		case 8:
			return memhash64(p, h, s)
		default:
			panic("unsupported size")
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		x := rv.Int()
		p := unsafe.Pointer(&x)

		switch t.Size() {
		case 1:
			return memhash8(p, h, s)
		case 2:
			return memhash16(p, h, s)
		case 4:
			return memhash32(p, h, s)
		case 8:
			return memhash64(p, h, s)
		default:
			panic("unsupported size")
		}
	case reflect.Float32:
		return f32hash(rv, h, s)
	case reflect.Float64:
		return f64hash(rv, h, s)
	case reflect.Complex64:
		return c64hash(rv, h, s)
	case reflect.Complex128:
		return c128hash(rv, h, s)
	case reflect.String:
		return strhash(rv, h, s)
	case reflect.Interface:
		elem := rv.Elem()
		return c1 * typehash(elem, h^c0, s)
	case reflect.Array:
		for i := 0; i < t.Len(); i++ {
			e := rv.Index(i)
			h = typehash(e, h, s)
		}
		return h
	case reflect.Struct:
		for i := 0; i < t.NumField(); i++ {
			f := t.Field(i)
			if f.Name == "" {
				continue
			}
			h = typehash(rv.Field(i), h, s)
		}
		return h

	// Go's map type doesn't support slice keys, but we will here for completeness
	case reflect.Slice:
		for i := 0; i < rv.Len(); i++ {
			e := rv.Index(i)
			h = typehash(e, h, s)
		}
		return h

	// Go's map type doesn't support map keys, but we will here for completeness
	case reflect.Map:
		mi := rv.MapRange()

		for mi.Next() {
			h = typehash(mi.Key(), h, s)
			h = typehash(mi.Value(), h, s)
		}
		return h
	default:
		// Should never happen, as typehash should only be called
		// with comparable types.
		panic(fmt.Errorf("hash of unhashable type %s", t))
	}
}

var processSeed = maphash.MakeSeed()

// Generate a hash value given the input. Hash values are stable only within
// the current process, and should not be serialized or attempted to be reused across
// process boundaries.
func Hash(val any) uint64 {
	return typehash(reflect.ValueOf(val), 0, processSeed)
}

// Generate a hash value given the input. Hash values are stable only within
// the current process, and should not be serialized or attempted to be reused across
// process boundaries.
func HashSeeded(val any, seed uint64) uint64 {
	return typehash(reflect.ValueOf(val), seed, processSeed)
}
